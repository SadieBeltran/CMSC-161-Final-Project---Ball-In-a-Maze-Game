<!doctype html>
<html>

<head>
  <title>Ball in A Maze</title>
</head>

<body>
  <canvas id="output" width="600" height="600"></canvas>

  <script src="./utils/gl-matrix.js"></script>
  <!-- VERTEX SHADER -->
  <script id="vertex-shader" type="notjs">#version 300 es
    in vec4 a_position;
    in float a_point_size;
    //transformation matrix
    uniform mat4 u_transformation_matrix;
    
    //For view, model, and projection transformations
    uniform mat4 u_model_matrix;
    uniform mat4 u_view_matrix;
    uniform mat4 u_projection_matrix;

    void main() {
      //Apply the transformations to the object to be rendered
      gl_Position = u_transformation_matrix * u_view_matrix * u_model_matrix * u_projection_matrix * a_position;
    }
  </script>

  <!-- FRAGMENT SHADER -->
  <script id="fragment-shader" type="notjs">#version 300 es
    precision mediump float;

    uniform vec4 u_color;
    out vec4 outColor;

    void main(void) {
      //outColor = vec4(1, 0, 0, 1); //red
    
      outColor = u_color;
    }

    
  </script>

  <!-- Function for creating and compiling shader programs -->
  <script>
    function createShader(gl, type, sourceCode) {
      // Compiles either a shader of type gl.VERTEX_SHADER or gl.FRAGMENT_SHADER
      var shader = gl.createShader(type);
      gl.shaderSource(shader, sourceCode);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        var info = gl.getShaderInfoLog(shader);
        throw 'Could not compile WebGL program. \n\n' + info;
      }
      return shader;
    }
  </script>

  <!-- Main function contains: 
    1) declaration of WebGL context
    2) function calls to initialize the shader programs
    3) declaration and binding of buffer object
    4) function calls to perform transformations before drawing
    5) draw/redraw functions
  -->
  <script src="./vertices.js"></script>
  <script src="./lib/rotate.js"></script>
  <script>
    function main() {

      const canvas = document.querySelector('#output');
      if (!canvas) {
        console.log("Canvas element with specified ID ('output') cannot be found.");
      }
      //const gl = initWebGL(canvas, true);
      //Setting up the WebGL Context
      const gl = canvas.getContext('webgl2');
      const vertexShaderSource = document.querySelector('#vertex-shader').text;
      const fragmentShaderSource = document.querySelector('#fragment-shader').text;
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);


      //Creation and initialization of GL program 
      var program = gl.createProgram();

      // Attach pre-existing shaders
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);

      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        var info = gl.getProgramInfoLog(program);
        throw 'Could not compile WebGL program. \n\n' + info;
      }

      // set the program created earlier
      gl.useProgram(program);

      // Declaration of pointers to the attributes
      const aPositionPointer = gl.getAttribLocation(program, 'a_position');
      const aPointSizePointer = gl.getAttribLocation(program, 'a_point_size');

      var colorLocation = gl.getUniformLocation(program, "u_color");

      //Used for affine transformation
      const uTransformationMatrixPointer = gl.getUniformLocation(program, 'u_transformation_matrix');

      const uModelMatrixPointer = gl.getUniformLocation(program, 'u_model_matrix');
      const uViewMatrixPointer = gl.getUniformLocation(program, 'u_view_matrix');
      const uProjectionMatrixPointer = gl.getUniformLocation(program, 'u_projection_matrix');

      const color1 = [0, 0, 1, 1];

      //Initializing the variables and tranformation matrix
      var tx = 0, ty = 0;
      var transformationMatrix = [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1
      ];

      // setup model matrix;
      const modelMatrix = glMatrix.mat4.create();
      glMatrix.mat4.rotateZ(modelMatrix, modelMatrix, glMatrix.glMatrix.toRadian(0));

      // setup view matrix
      const viewMatrix = glMatrix.mat4.create();
      const cameraPosition = [0, 0.5, -0.2]; // Adjust position for better viewing angle
      const lookAtPoint = [0, 0, 0];      // Center of the object
      const upVector = [0, 0.1, 0];  

      // Create the view matrix
      glMatrix.mat4.lookAt(viewMatrix, cameraPosition, lookAtPoint, upVector);


      // setup projection matrix
      const projectionMatrix = glMatrix.mat4.create();

      // Update the orthographic projection
      const left = -1;
      const right = 1;
      const bottom = -1;
      const top = 1;
      const near = -1;   // Should encompass the object's minimum depth
      const far = 1.5;     // Should be greater than the camera's maximum depth


      glMatrix.mat4.ortho(projectionMatrix,left, right, bottom, top, near, far);

      // function for matrix multiplication
      function multiplyMatrices(mat1, mat2) {
        let resulting_matrix = [];
        for (let row = 0; row < 4; row++) {
          for (let col = 0; col < 4; col++) {
            let sum = 0;
            for (let elem = 0; elem < 4; elem++) {
              sum += mat1[row * 4 + elem] * mat2[elem * 4 + col];
            }
            resulting_matrix.push(sum);
          }
        }
        return resulting_matrix;
      }

      // function for converting the 2d array to 1d 
      function listarray_to_array(listarray) {
        arr = [];
        for (let i = 0; i < listarray.length; i++) {
          arr.push(listarray[i][0]);
          arr.push(listarray[i][1]);
          arr.push(listarray[i][2]);
          arr.push(listarray[i][3]);
        }
        return arr;
      }
      // function to draw the scene from the user inputs
      function drawScene() {
        // clear the screen before drawing anything
        gl.clearColor(0.0, 0.0, 0.0, 1.0); // black - RGBA
        gl.clear(gl.COLOR_BUFFER_BIT); //execute

        // load uniforms (only done once; since values are same for all vertices)
        gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(modelMatrix));
        gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));
        gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));
        // set values
        gl.uniformMatrix4fv(uTransformationMatrixPointer, false, new Float32Array(transformationMatrix));
        let color_change = 0
        for (let i = 0; i < parts.length; i++) {
          //Buffer object to be accessed by gl.ARRAY_BUFFER
          //create a buffer object
          var shapeBuffer = gl.createBuffer();

          //Bind buffer object to a target
          gl.bindBuffer(gl.ARRAY_BUFFER, shapeBuffer);
          color_change = color_change + 0.01;
          //Write data into the buffer object
          next_bufferdata = listarray_to_array(parts[i]);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(next_bufferdata), gl.STATIC_DRAW);

          //Assign the buffer object to an attribute variable
          gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);

          //Enable assignment
          gl.enableVertexAttribArray(aPositionPointer);

          // draw buffer that is bound to gl.ARRAY_BUFFER
          if (parts[i]==inner){
          gl.uniform4f(colorLocation, color1[0], color1[1],color1[2], 0.2);} else{

          gl.uniform4f(colorLocation, color1[0], color1[1] + color_change, color1[2] + color_change, 1);
          }
          // gl.vertexAttrib1f(aPointSizePointer, 2.0);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, parts[i].length);

          //unbind the buffer
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
      }
      // initial render
      drawScene();

      rotateListener(modelMatrix, drawScene, glMatrix.mat4.rotate);
    }
    main();
  </script>
</body>

</html>